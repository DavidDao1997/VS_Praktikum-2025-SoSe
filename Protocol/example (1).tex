\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{geometry}
\geometry{a4paper, margin=2.5cm}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{listings}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{booktabs}
\usepackage{array}

\title{Wochenbericht I - Praktikum "Verteilte Systeme": Lösung des Philosophenproblems und Architekturelle Überlegungen}
\author{Lisa Test}
\date{\today}

\lstset{
    language=Java,                
    basicstyle=\footnotesize\ttfamily,
    numbers=left,                  
    numberstyle=\tiny\color{gray},
    stepnumber=1,                   
    numbersep=5pt,                 
    backgroundcolor=\color{white}, 
    showspaces=false,               
    showstringspaces=false,         
    showtabs=false,                
    frame=single,                 
    tabsize=4,                      
    captionpos=b,                   
    breaklines=true,                
    breakatwhitespace=true,        
    title=\lstname,               
    escapeinside={\%*}{*)},         
    morekeywords={Integer,IntWritable, Iterable, Text},
}

\begin{document}
\maketitle
\section{Mitglieder des Projektes }

\begin{tabular}{>{\raggedright\arraybackslash}p{3cm} >{\raggedright\arraybackslash}p{4cm} >{\centering\arraybackslash}p{2cm} >{\centering\arraybackslash}p{2cm} >{\raggedright\arraybackslash}p{3cm}}
\toprule
\textbf{Mitglied des Projektes} & \textbf{Aufgabe} & \textbf{Fortschritt} & \textbf{Zeiteinsatz} & \textbf{Reviewer} \\
\midrule
Max Mustermann & Entwurf der Systemarchitektur & 75\% & 60 Min & Erika Beispiel \\
\hline
Erika Beispiel & Implementierung der Kernkomponenten & 50\% &  10 Min & Lisa Test \\
\hline
Lisa Test & Erstellung der Benutzeroberfläche & 25\% & 1 Stunde & Max Mustermann \\
\hline
Peter Entwickler & Erstellung der Komunnikationsschnittstelle & 90\% & 0 Minuten & Max Mustermann \\
\bottomrule
\end{tabular}

\section{Zusammenfassung der Woche}

Diese Woche haben wir unsim Rahmen des Milestones I mit der Lösung des Philosophenproblems in einem verteilten System befasst. Ziel war es, ein lauffähiges System zu entwickeln und gleichzeitig architektonische Überlegungen und Algorithmen auf Basis des Skripts „Verteilte Systeme“ zu validieren.
\\\\
Wesentliche Pull Requests des Projektes waren:\\
- Beispiel1 xs344343f \\
- Beispiel2 ghhrf543f \\
- Beispiel3 xsfef3343f \\

\section{Bearbeitete Themen und Schlüssel Erkenntnisse}

\subsection{Das Philosophenproblem als Herausforderung für verteilte Systeme}
Das Philosophenproblem (Skript S. 253ff) diente als konkretes Anwendungsbeispiel, um die Herausforderungen bei der Koordination und Synchronisation von Prozessen in verteilten Systemen zu verstehen. Insbesondere wurde die Notwendigkeit der Vermeidung von Deadlocks und Verhungern (Starvation) deutlich.

\subsection{Architekturentwurf und Protokolle}
In Anlehnung an die Diskussion über die Verteilung der Daten (Skript S. 47ff) und über die Notwendigkeit der Koordination (Skript S. 219ff) wurde eine Microservice-Architektur mit separaten Services für jeden Philosophen und einen zentralen Service zur Verwaltung der Gabeln entworfen. Die Kommunikation erfolgte über ein leichtgewichtiges Nachrichtenprotokoll (MQTT), um die Latenz zu minimieren.

\subsection{Algorithmen zur Konsensfindung}
Um sicherzustellen, dass die Philosophen sich auf die Aufnahme der Gabeln einigen können, wurde eine Variante des Bakery Algorithm“ (Skript S. 229ff) adaptiert. Jeder Philosoph erhält eine Ticketnummer, und nur der Philosoph mit der niedrigsten Ticketnummer darf auf die Gabeln zugreifen.



\section{Bezug zum Skript}

Die in diesem Praktikumsbericht dargestellten Ansätze zur Konsensfindung und Koordination in verteilten Systemen stehen in direkter Verbindung zu den theoretischen Grundlagen, die in dem Skript „Verteilte Systeme – Prinzipien und Paradigmen“ von Tanenbaum und van Steen (2017) erläutert werden.

Insbesondere die Herausforderungen, die beim Entwurf fehlertoleranter Algorithmen auftreten, wurden durch die Diskussion des CAP-Theorems (Skript S. 220) deutlich. Die Unvereinbarkeit von Konsistenz, Verfügbarkeit und Partitionstoleranz zwang uns, Kompromisse bei der Implementierung der Konsensfindung zu eingehen.

\subsection{Diskussion der Algorithmuswahl}

Die anfängliche Wahl fiel auf eine zentrale Lösung (ähnlich dem Ansatz im Skript S. 277), da diese einfacher zu implementieren und zu verwalten schien. Jedoch wurde schnell deutlich, dass ein Single Point of Failure ein inakzeptables Risiko für unser System darstellt. Ein Ausfall des zentralen Koordinators würde das gesamte System lahmlegen.

\textbf{Zitat}: „Bei der Entscheidung zwischen zentralisierten und dezentralisierten Algorithmen muss sorgfältig geprüft werden: ... Die Auswirkungen auf die Skalierbarkeit, Robustheit und Sicherheit" (Skript S. 277).

In der Folge wurde die Implementierung eines verteilten Konsensalgorithmus in Erwägung gezogen. Allerdings stellte sich heraus, dass die Integration eines solchen Algorithmus in der gegebenen Zeit nicht machbar wäre und die geforderten Anforderungen mit den gegebenen Ressourcen nicht einzuhalten ist. Daher wurde ein Kompromiss gefunden, der eine einfache Redundanz des Koordinators vorsieht.

Die Wahl des Algorithmus orientiert sich an den Kapiteln 7, 8 des Skriptes (Algorithmen und Betrieb).

\subsection{Kritische Reflexion}

Die im Praktikum gewählte Kompromisslösung ist jedoch nicht ohne Risiken. Die fehlende Garantie für vollständige Fehlertoleranz bedeutet, dass das System bei einem gleichzeitigen Ausfall des primären und sekundären Koordinators immer noch ausfallen kann. In zukünftigen Iterationen sollte daher die Implementierung eines verteilten Konsensalgorithmus angestrebt werden, um die Robustheit des Systems weiter zu erhöhen.

Zudem wurden in den praktischen Übungen der Implementierung auch Erfahrungen in Bezug auf die Virtualisierung von Prozessen gesammelt wie in der der Einleitung schon genannt wird.

\textbf{Zitat:} "(Virtualisierung) Dies ermöglicht eine schnellere Reaktion auf Änderungen in der Arbeitslast und erleichtert die Anpassung an unterschiedliche Anforderungen." (Skript S.13)

Ich hätte es als eine Verbesserung angesehen wenn in dieser Ausarbeitung das Beispiel der verteilten Uhren eine deutlichere Bedeutung erhalten hätte, die zur Validierung der Zeitstempel verwendet werden. Die Implementierung, die von verschiedenen Protokollen vorgeschlagen und verworfen wurden, hätte durchaus eine Diskussion gerechtfertigt, die auf einer Analyse der zu übertragenden Datenmengen basiert.

\textbf{Zitat:} "Die Herausforderung in diesem Fall ist nicht das Verständnis für den Algorithmus, sondern
die Herausforderung beginnt im Anforderungsprozess des verteilten Systems. Es ist wichtig zu beachten, dass der vorgestellte Lösungsansatz nur funktioniert, da das Labyrinth als Graph modelliert werden konnte, und der Informatiker dies in der Anforderungsanalyse erkennt." (Skript S.15)

Diese Auseinandersetzung mit dem Anforderungsprozess, hat geholfen aus der Vielzahl an Informationen die Richtigen zu selektieren und mit den verfügbaren Mitteln auch eine gute Lösung zu realisieren.


\section{Nächste Schritte}

Implementierung eines Konsensalgorithmus (Raft/Paxos) zur Erhöhung der Fehlertoleranz.

Optimierung des Netzwerkverkehrs durch Batch-Verarbeitung von Anfragen.

Erweiterung des Systems um zusätzliche Ressourcen, wie z.B. dynamische Vergabe der Verfügbarkeit.

\end{document}
