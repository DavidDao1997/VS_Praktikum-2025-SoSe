\chapter{Lösungsstrategie}
Als grundlegendes Architekturprinzip wurde das Model-View-Controller-(MVC)-Muster eingesetzt, um eine klare Trennung zwischen Anwendungslogik (Model), Steuerung (Controller) und Darstellung (View) sicherzustellen
\footnote{\url{https://github.com/scimbe/vs_script/blob/main/vs-script-first-v01.pdf} S.90-94}. 
Dieses Prinzip der \textit{Separation of Concerns} bildete den Ausgangspunkt der Umsetzung und erleichterte den strukturierten Einstieg in die Entwicklung. 
Durch die konsequente Aufteilung in klar abgegrenzte Verantwortlichkeiten konnten die funktionalen Anforderungen frühzeitig in kleinere, handhabbare Arbeitspakete überführt werden. 
Dies förderte sowohl die Parallelisierung einzelner Entwicklungsaufgaben als auch die Wartbarkeit und Erweiterbarkeit der Lösung im weiteren Verlauf des Projekts.

% \footnote{\url{https://github.com/scimbe/vs_script/blob/main/vs-script-first-v01.pdf} S.98 f.}
% Wenn ich auf etwas einmal schon verwiesen haben, muss ich es nochmal tuen? 


\clearpage
\section{Controller}

In der vorliegenden Architektur übernimmt der Controller nicht mehr die klassische Rolle eines Observers, sondern fungiert als schlanker, zustandsloser Vermittler zwischen Modell und View im Sinne des MVC-Musters. \\
Anstelle eines ereignisgesteuerten oder abfragenden (Pull-)Ansatzes sendet das Modell in regelmäßigen Intervallen aktiv (Push-basiert)\footnote{\url{https://github.com/scimbe/vs_script/blob/main/vs-script-first-v01.pdf} S.209-211} seinen aktuellen Zustand an den Controller. \\
Dieser verarbeitet die empfangenen Daten nicht weiter, sondern leitet sie unmittelbar und unverändert an die View weiter.\\
Sobald sie aktiv ist, erhält sie automatisch den zuletzt übermittelten Zustand.\\
Der Controller bleibt vollständig zustandslos\footnote{\url{https://github.com/scimbe/vs_script/blob/main/vs-script-first-v01.pdf} siehe S. 57-58,89,137}: Er speichert weder frühere Zustände noch verarbeitet er Eingaben oder beinhaltet Geschäftslogik. \\
Zudem erfolgt keine Rückrichtung von der View zum Modell. \\
Die klare Trennung der Verantwortlichkeiten sowie der rein gerichtete Datenfluss erhöhen die Robustheit der Anwendung, reduzieren potenzielle Fehlerquellen und fördern die Wiederverwendbarkeit der Komponenten.\\
\begin{table}[h!]
    \centering
    \begin{tabular}{|p{5cm}|p{5cm}|p{5cm}|}
        \hline
        \textbf{Funktion} & \textbf{Voraussetzung} & \textbf{Semantik} \\
        \hline
        void update(robots: String[], selected: int, error: bool, confirm: bool) & Modell sendet periodisch aktuellen Zustand & Controller leitet Daten unmittelbar an View weiter \\
        \hline
        void reportHealth(serviceName: String, subscription: String) & Gültiger Servicename und Abonnement vorhanden & Meldet den Gesundheitszustand eines Dienstes an das Modell zurück. \\
        \hline
    \end{tabular}
    \caption{Funktionen des Controllers}
    \label{tab:Controller}
\end{table}

\clearpage

% Bin mir in diesen bereich nicht wirklich sicher. Versuche mit Notebook die jeweilige punkte abzudecken, aber warum wir es genau sogemacht haben - ist mir noch fremd.
% Sollten eventuell über die schritte nochmal genauer reden.
\section{Model}
Im Rahmen der gewählten MVC-Architektur übernimmt das \textit{Model} die zentrale Rolle bei der Verwaltung des Anwendungszustands und der Geschäftslogik.\footnote{\url{https://github.com/scimbe/vs_script/blob/main/vs-script-first-v01.pdf} S.90-94}
Gemäß dem Prinzip der \textit{Separation of Concerns} ist das Model ausschließlich für Datenhaltung und Zustandsverwaltung zuständig und ist dabei losgelöst von Darstellung und Steuerung. 
Die nachfolgenden Funktionen sind bewusst im Model (StateService) verankert, da sie direkt die Verwaltung und den Zustand des Roboterarms betreffen.
\\\\% Hab ein Problem hier, da eigentlich der komplette Core das Modell ist, oder ich verstehe irgendwas nicht richtig
Die Kapselung dieser Funktionen im Model stellt sicher, dass Zustandslogik, Validierung und Datenverarbeitung zentral gebündelt sind\footnote{\url{https://github.com/scimbe/vs_script/blob/main/vs-script-first-v01.pdf} S.91 und S.137}.
Die View bleibt vollständig abstrahiert und erhält ausschließlich aktualisierte Daten über den Controller. 

\subsection{StateService}
\begin{table}[h!]
    \centering
    \begin{tabular}{|p{5cm}|p{5cm}|p{5cm}|}
        \hline
        \textbf{Funktion} & \textbf{Voraussetzung} & \textbf{Semantik} \\
        \hline
        void setError(error: boolean, confirm: boolean) & Änderung des Fehler- oder Bestätigungsstatus notwendig & Setzt den Fehler- und Bestätigungsstatus und benachrichtigt den Controller. \\
        \hline
        void select(SelectDirection selectDirection) & Liste der verfügbaren Roboterarme ist nicht leer & Wählt einen Roboterarm aus der Liste der verfügbaren Roboterarme aus und aktualisiert den Status. \\
        \hline
        void registerActuator(actuatorName: String, isAlive: boolean) & Motorname im richtigen Format (z.\,B.\ R1A1) & Registriert den Motor und ergänzt ggf. die Roboterarmverfügbarkeitsliste. \\
        \hline
        void reportHealth(serviceName: String, subscription: String) & Gültiger Servicename und Abonnement vorhanden & Meldet den Gesundheitszustand eines Dienstes an das Modell zurück. \\
        \hline
        boolean isAvailable() & keine & Prüft, ob alle vier Aktoren (A1–A4) des Roboterarms aktiv sind. Gibt \texttt{true} zurück, wenn der Roboterarm vollständig verfügbar ist. \\
        \hline
    \end{tabular}
    \caption{Funktionen der Komponente StateService}
    \label{tab:StateService}
\end{table}
\clearpage
Der \texttt{StateService} bildet das zentrale Zustandsmodell der Anwendung und ist als Teil der Model-Komponente im Sinne des MVC-Musters zu verstehen. 
Er verwaltet den internen Systemzustand wie Fehlerstatus, Aktorverfügbarkeit, Roboterarmselektion und Gesundheitsinformationen. 
Alle domänenspezifischen Funktionen, die sich auf den Roboterarmzustand und dessen Verwaltung beziehen, sind hier gebündelt. 
Somit kapselt der \texttt{StateService} nicht nur die Daten, sondern auch die zugehörige Logik zur Interpretation und Aktualisierung ein zentrales Merkmal von Modellkomponenten in verteilter Anwendungsarchitektur.



    % \subsection{StateService}
    % \begin{table}[h!]
    %     \centering
    %     \begin{tabular}{|p{5cm}|p{5cm}|p{5cm}|}
    %         \hline
    %         \textbf{Funktion} & \textbf{Voraussetzung} & \textbf{Semantik} \\
    %         \hline
    %         void select(SelectDirection selectDirection) & Liste der verfügbaren Roboter ist nicht leer & Wählt einen Roboter aus der Liste der verfügbaren Roboter aus und aktualisiert den Status. \\
    %         \hline
    %         void select(int sd) & sd ist ein gültiger Index für die SelectDirection-Enum & Ruft die Auswahl eines Roboters basierend auf dem Richtungsindex auf. \\
    %         \hline
    %         void setError(boolean error, boolean confirm) & Änderung des Fehler- oder Bestätigungsstatus notwendig & Setzt den Fehler- und Bestätigungsstatus und benachrichtigt den Controller. \\
    %         \hline
    %         void register(String motorName) & Motorname im richtigen Format (z.B. R1A1) & Registriert den Motor und fügt den zugehörigen Roboter der Verfügbarkeitsliste hinzu, falls dieser vollständig ist. \\
    %         \hline
    %         void subscribe() & keine & Placeholder-Methode, aktuell ohne Implementierung. \\
    %         \hline
    %         String getSelected() & Ein Roboter ist ausgewählt (selectedRobot > 0) & Gibt den Namen des aktuell ausgewählten Roboters zurück. \\
    %         \hline
    %         private void sendUpdate() & Änderungen im Status des StateService & Benachrichtigt den Controller über die aktuellen Verfügbarkeiten und Zustände. \\
    %         \hline
    %         boolean isAvailable() & keine & Prüft, ob alle vier Aktoren (A1, A2, A3, A4) des Roboters aktiviert sind. Liefert \texttt{true}, wenn der Roboter vollständig verfügbar ist. \\
    %         \hline
    %     \end{tabular}
    %     \caption{Funktionen der Komponente StateService inklusive Robot-Klasse}
    %     \label{tab:StateService}
    % \end{table}

\subsection{MoveAdapter}
    \begin{table}[h!]
        \centering
        \begin{tabular}{|p{5cm}|p{5cm}|p{5cm}|}
            \hline
            \textbf{Funktion} & \textbf{Voraussetzung} & \textbf{Semantik} \\
            \hline
            void move(robotDirection: RobotDirection) & Ein Roboterarm ist im StateService ausgewählt und verfügbar & Führt eine Bewegungsanweisung in der angegebenen Richtung für den aktuell ausgewählten Roboterarm aus. \\
            \hline
            void setSelected(selected: String) & Der angegebene Roboterarmname existiert im StateService & Setzt den angegebenen Roboterarm als aktuell ausgewählten und initialisiert ggf. die Bewegung. Fehler werden im StateService registriert. \\
            \hline
        \end{tabular}
        \caption{Funktionen des MoveAdapter}
        \label{tab:MoveAdapter}
    \end{table}
    
Der \texttt{MoveAdapter} ist eine zustandsbehaftete Komponente innerhalb des Modells. Er verwaltet die Auswahl eines Roboterarms und führt kontextbezogene Bewegungsbefehle aus. 
Die Methode \texttt{setSelected()} speichert den ausgewählten Roboterarm intern, während \texttt{move()} Bewegungen für genau diesen ausführt. 
Durch die lokale Zustandsführung wird die Trennung von Logik, Steuerung und Darstellung gestärkt und die Konsistenz der Bewegungsoperationen sichergestellt.

\clearpage
% new version ActuatorController
    \subsection{ActuatorController}
        \begin{table}[h!]
            \centering
            \begin{tabular}{|p{5cm}|p{5cm}|p{5cm}|}
                \hline
                \textbf{Funktion} & \textbf{Voraussetzung} & \textbf{Semantik} \\
                \hline
                void move(ActuatorDirection actuatorDirection) & Der Aktuator ist initialisiert & Bewegt den Aktuator in die angegebene Richtung (INCREASE oder DECREASE) und setzt den neuen Wert. \\
                \hline
            \end{tabular}
            \caption{Funktionen der Komponente ActuatorController}
            \label{tab:ActuatorController}
        \end{table}
Der \texttt{ActuatorController} ist eine funktionale Komponente innerhalb des Anwendungskerns, die für die konkrete Steuerung eines Aktuators verantwortlich ist. 
Sie kapselt die Logik zur Positionsveränderung eines Aktuators entlang einer vorgegebenen Richtung (\texttt{INCREASE} oder \texttt{DECREASE}). Die Methode \texttt{move()} setzt den neuen Positionswert und stellt sicher, dass nur der initialisierte Aktuator angesteuert wird. 
Damit ergänzt der \texttt{ActuatorController} die Bewegungslogik auf unterer Ebene und unterstützt die feingranulare Steuerung innerhalb der Gesamtarchitektur.

\section{View}
Die View besteht aus den unabhängigen Blöcken IO und UI. Die UI bietet eine Softwareschnittstelle an, die IO keine.

% Marc's schnistelle - Funktionen müssen überarbietet werden
% \subsection{IO Funktionen}
% \begin{table}[h!]
%     \centering
%     \begin{tabular}{|p{5cm}|p{5cm}|p{5cm}|}
%         \hline
%         \textbf{Funktion} & \textbf{Voraussetzung} & \textbf{Semantik} \\
%         \hline
%         void readInputs() & Eingabe durch den Benutzer erfolgt & Überprüft die Benutzereingaben und löst entsprechende Aktionen aus. \\
%         \hline
%         int initIO() & IO-Hardware verfügbar & Initialisiert und überprüft die IO-Hardwareschnittstellen und gibt einen Fehlercode bei Problemen zurück. \\
%         \hline
%     \end{tabular}
%     \caption{IO Funktionen}
%     \label{tab:IOFunktionen}
% \end{table}
\subsection{Interne IO-Funktionen}
\begin{table}[h!]
    \centering
    \begin{tabular}{|p{5cm}|p{5cm}|p{5cm}|}
        \hline
        \textbf{Funktion} & \textbf{Voraussetzung} & \textbf{Semantik} \\
        \hline
        void readButtons() & Eingabetasten sind verbunden & Liest den aktuellen Zustand aller Tasten aus. \\
        \hline
        bool isAnyButtonPressed(lastBtn: int) & Taste wurde zuvor gedrückt & Überprüft, ob dieselbe Taste weiterhin gedrückt wird.\\
        \hline
        void toggleState() & Zustand soll gewechselt werden & Wechselt den aktuellen Zustand. Kann erweitert werden, um zusätzliche Funktionen auszulösen. \\
        \hline
    \end{tabular}
    \caption{Interne IO-Funktionen}
    \label{tab:interneIOFunktionen}
\end{table}


\clearpage
% Hat sich nicht verändert
\subsection{UI Funktionen}
\begin{table}[h!]
    \centering
    \begin{tabular}{|p{5cm}|p{5cm}|p{5cm}|}
        \hline
        \textbf{Funktion} & \textbf{Voraussetzung} & \textbf{Semantik} \\
        \hline
        void updateView(robots: String[],selected: int, error: bool, confirm: bool) & Gültige Modell-Daten vorhanden & View-Schnittstelle. Aktualisiert die UI mit den neuesten Roboterarm-Daten und Statusinformationen (Fehler, Bestätigung). \\ 
        \hline
    \end{tabular}
    \caption{UI Funktionen}
    \label{tab:UIFunktionen}
\end{table}

% Die UI-Funktionen übernehmen im Rahmen des MVC-Musters die rein visuelle Darstellung des aktuellen Modellzustands. 
% Die zentrale Methode \texttt{updateView()} wird vom Controller innerhalb der Anwendungsschicht aufgerufen, sobald neue Zustandsinformationen aus dem Modell vorliegen.
% Die Benutzeroberfläche wird in einem HTML-basierten Webbrowser dargestellt. 
% Diese Gestaltung folgt dem Prinzip der Client-Server-Architektur: Der Browser fungiert als leichtgewichtiger Client, der ausschließlich für die Präsentation zuständig ist, während Geschäftslogik und Zustandsverwaltung vollständig in der Anwendung verbleiben.\footnote{\url{https://github.com/scimbe/vs_script/blob/main/vs-script-first-v01.pdf} S.82 f.} 
% Dadurch wird eine plattformunabhängige und benutzerfreundliche Bedienoberfläche ermöglicht.\footnote{\url{https://github.com/scimbe/vs_script/blob/main/vs-script-first-v01.pdf} S.23}

Die UI-Funktionen übernehmen im Rahmen des MVC-Musters die rein visuelle Darstellung des aktuellen Modellzustands. 
Die zentrale Methode \texttt{updateView()} wird vom Controller innerhalb der Anwendungsschicht aufgerufen, sobald neue Zustandsinformationen aus dem Modell vorliegen. 
Die Benutzeroberfläche wird in einem HTML-basierten Webbrowser dargestellt. 
Ein HTTP-Server stellt die statischen HTML-Inhalte klassisch im Client-Server-Modell bereit. 
Für die Aktualisierung des UI-Zustands kommt zusätzlich eine WebSocket-Verbindung zum Einsatz, über die neue Modellinformationen entsprechend unserer definierten Datenflussrichtung direkt vom Server an den Browser übertragen werden. 
Auf diese Weise wird die Oberfläche automatisch an neue Zustände angepasst, ohne dass wiederholte Client-Anfragen notwendig sind.


% HTML wird klassische Client-Server geserved, aber das update wird entsprechend unserer Datenffluss richtung mit hilfe von Websocket in dem Browser gepusht