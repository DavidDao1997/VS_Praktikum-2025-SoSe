\chapter{Kontextabgrenzung}


\section{Fachlicher Kontext}


\subsection{Akteure und Rollen}

\begin{tabular}{|p{4cm}|p{10cm}|}
	\hline
	\textbf{Akteur / Rolle} & \textbf{Beschreibung} \\
	\hline
	Server (Applikation) & Ein einzelner Teilnehmer. Meldet sich eigenständig bei der Middleware mit seinen Diensten an. \\
	\hline
	Client (Applikation) & Ein einzelner Teilnehmer. Kann die Dienste der anderen Teilnehmern aufrufen. \\
	\hline
	Health-Observable (Applikation) & Teilnehmer, der Lebenszeichen schickt \\
	\hline
	Health-Observer (Applikation) & Teilnehmer, der bei ausbleibenden Lebenszeichen benachrichtigt wird  \\
	\hline
\end{tabular}

\subsection{Fachliche Aufgaben (Use Cases)}

\begin{tabular}{|p{1.5cm}|p{4cm}|p{8.5cm}|}
	\hline
	\textbf{ID} & \textbf{Name} & \textbf{Beschreibung} \\
	\hline
	U1 & Informationen weiterleiten & Die Middleware leitet RPCs von der Applikation an die entsprechenden Nodes weiter. \\
	\hline
	U2 & Node registrieren & Ein Server registriert seine Dienste bei der Middleware mit einem eindeutigen Identifier. Dem Identifier wird dessen Socket-Adresse zugeordnet. \\
	\hline
	U3 & Namen auflösen & Die Middleware ermittelt, welche Dienste bei welcher Socket-Adresse zu finden sind.\\
	\hline
	U4 & Marshalling & Die Middleware definiert eine IDL. Diese muss dafür sorgen, dass die Datenstrukturen und Parameter der Funktionsaufrufe via RPC korrekt in ein übertragbares Format (Marshalling) umgewandelt und am Zielsystem wieder entpackt (Unmarshalling) werden. \\
	\hline
	U5 & Transport & Die RPCs werden via UDP über die Netzwerkschicht transportiert. Das ist durch die Echtzeitanforderung bedingt. Kommunikation findet asynchron statt. Synchronizität wird durch mehrere asynchrone RPCs umgesetzt.\\
	\hline 
	U6 & Sicherheit & Versendete RPCs haben (zwischen Client und Server) Echtzeitanforderungen. \\
	\hline
	U7 & Watchdog & Der Watchdog informiert Subscriber ob andere Services verfügbar sind.\\      %Für überwachte Health-Observables werden Watchdogs angelegt. Diese überwachen die Verfügbarkeit der Teilnehmer, wenn Lebenszeichen ausbleiben werden Health-Observer benachrichtigt.  \\
	\hline
	
\end{tabular}

\subsection{Fachliche Randbedingungen}

\begin{itemize}
	\item Es können bis zu 253 Nodes mit unterschiedlichen IPv4-Adressen gleichzeitig betrieben werden.
	\item Es wird IPv4 gefordert, daher muss das TCP/IP-Modell für den Transport genutzt werden. 
	%\item Jeder Server hat einen eindeutigen Namen. Dieser gruppiert Dienste.
	%\item Die Middleware muss mit dem Ausfall oder der Nichterreichbarkeit einzelner Nodes robust umgehen können.
	%\item Die Systemsicherheit hat höchste Priorität: Weiterleitungen ungültiger RPCs an die Applikation müssen verhindert werden. Es muss eine Fehlermeldung an die Applikation erfolgen. 
	\item Die Middleware dient als Vermittler bzw, Abstraktionsschicht. Dadurch ist mindestens eine indirekte Kopplung zu implementieren. Um eine hohe Skalierbarkeit oder Fehlertoleranz zu erreichen, ist eine losgekoppelte Kopplung zu implementieren.
\end{itemize}

\section{Technischer Kontext}

Die Middleware positioniert sich technisch als Vermittlungsschicht zwischen der Anwendungsebene und den darunterliegenden Betriebssystem- und Kommunikationsdiensten. Sie ist über mehrere Teilnehmer verteilt, die über ein lokales /24 Netzwerk miteinander verbunden sind.
Die Middleware nutzt Netzwerkprotokolle, insbesondere UDP, sowie Betriebssystemfunktionen, um eine zuverlässige Kommunikation zu gewährleisten. Gleichzeitig bietet sie den Anwendungen eine abstrahierte, einheitliche Schnittstelle, die die Heterogenität der zugrundeliegenden Systeme verbirgt. Aus diesem Grund eignet sich in den folgenden Abschnitte eine funktionale Zerlegung. Mit dieser kann die Middleware alle geforderten Ziele eines verteilten Systems einhalten. Mit einer ressourcen-basierten Zerlegung ist dies komplexer.

\subsection{Technische Anforderungen an die Middleware}

Um die fachlichen Use Cases umzusetzen, muss die Middleware folgende technische Funktionen bereitstellen:

\begin{itemize}
	\item \textbf{Informationen weiterleiten U1:}\\
	\begin{itemize}
		\item Schnittstelle zur Applikation zum entfernten Funktionsaufruf und dessen Parameter.
		\item Einheitliche Übersetzung und Serialisierung. 
		\item Namensauflösung, ggf. aus Cache.
		\item Transport der Nachricht über Netzwerk. 
		\item Deserialisierung der empfangenen Aufrufs.
		\item Schnittstelle zur Applikation, um lokalen Funktionsaufruf auszuführen.  
	\end{itemize}
	
	\item \textbf{Node registrieren U2:}\\
	\begin{itemize}
		\item Schnittstelle zur Applikation mit Gruppen Name, Funktionsname und seiner Socket-Adresse via RPC
		\item Einheitliche Übersetzung und Serialisierung 
		\item Senden an bekannten Namensserver
		\item Deserialisierung der empfangenen Aufrufs am Namensserver
		\item Eintragen der Informationen
	\end{itemize}
	
	\item \textbf{Namen auflösen U3:}\\
	\begin{itemize}
		\item Senden der Anfrage mit Parameter (Gruppen Name, Funktionsname, eigener Gruppenname, Funktionsname der Antwort) via RPC
		\item (Einheitliche Übersetzung und Serialisierung)
		\item Senden an bekannten Namensserver
		\item Warten auf Antwort
		\item (Deserialisierung des empfangenen Aufrufs am Namensserver)
		\item Auflösen der Socket-Adresse zum Funktions- und Gruppennamen
		\item Aufruf der Antwortsfunktion anhand Gruppenname mit Parameter(Socketadresse)
		\item (Einheitliche Übersetzung und Serialisierung )
		\item Senden an vorherigen Sender
		\item (Deserialisierung der empfangenen Aufrufs)
		\item Einsetzen der Socketadresse im Cache
	\end{itemize}
		
	\item \textbf{Marshalling U4:}\\
	\begin{itemize}
		\item Aufruf des Marshallings mit Parameter (Funktionsname, Liste von Typisierten Parameter)
		\item Übersetzen der Funktion und der Parameter mittels IDL in ein serialisierbaren Typen (char-array)
		\item (Versenden der Nachricht)
		\item Aufruf des Unmarshallings mit Parameter (serialisierter Funktionsaufruf)
		\item Übersetzen serialisierter Funktionsaufruf in eine Funktion und der Parameter (Funktionsname, Liste von Typisierten Parameter) mittels IDL
	\end{itemize}
	
	\item \textbf{Transport U5:}\\
	\begin{itemize}
		\item Aufruf der Netzwerkschicht mit Parameter (Serialisierter Funktionsaufruf)
		\item Empfang des serialisierten Funktionsaufrufs
		\item Deserialisierung der Serialisierung
	\end{itemize}
	
	\item \textbf{Sicherheit U6:}\\
	\begin{itemize}
		\item Auslesen des eigenes Timestamps 	
		\item (Einheitliche Übersetzung und Serialisierung)
		\item Senden an alle möglichen Sender
		\item empfangen der Nachricht und Deserialisieren
		\item Setzen des Timestamps bei zugehörigem  Empfänger
		\item Nutzung des Timestamps bei Nachricht an Empfänger
	\end{itemize}
	
	\item \textbf{Watchdog U7:}\\
	\begin{itemize}
		\item Senden eines Subscriber-Requests an einen zentralen Watchdog
		\item Periodisches Senden eines Heartbeats an den Watchdog
		\item Senden von periodischen Healthreports an die Subscriber		
	\end{itemize}
\end{itemize}
	
\section{Externe Schnittstellen}

Die Middleware besitzt folgende Schnittstellen:

\begin{itemize}
	\item \textbf{Schnittstelle zur Anwendungsebene:}  
	Bietet eine einheitliche API, über die Anwendungen (z.\,B. auf ITS-Board oder Raspberry Pis) verteilte Dienste nutzen, Nachrichten senden und empfangen können, sowie sich als Teilnehmer registrieren können, unabhängig von Netzwerkdetails oder physikalischer Verteilung.
	
	\item \textbf{Schnittstelle zu System- und Netzwerkschichten:}  
	Nutzt Betriebssystem- und Netzwerkdienste (TCP/IP, IPv4) zur Nachrichtenübermittlung und Ressourcenverwaltung. Diese Schnittstelle ist für die Anwendungen verborgen.
\end{itemize}