\chapter{Lösungsstrategie}


\section*{Kommunikation}
Die losgekoppelte Kopplung \textcolor{red}{TODO: Abschnitt}, fordert eine asynchrone Kommunikation ein. 
Durch die festgelegte funktionale Zerlegung \textcolor{red}{TODO: Abschnitt} ist RPC ein geeigneter Kommunikationsmechanismus \textcolor{red}{TODO: QUELLE}. Die losgekoppelte Kopplung fordert im TCP/IP Stack das Protokoll UDP ein, da TCP als verbindungsorientiertes Protokoll durch die ACK Pakete synchron arbeitet \textcolor{red}{TODO: Quelle}.	 Registrierungsvorgänge werden persistent gespeichert, während Steuerbefehle transient und zeitkritisch behandelt werden. Um sicherzustellen, dass pro RPC Aufruf nur ein UDP-Paket verschickt wird, darf die Payload die Größe von 256 Bytes nicht überschreiten \textcolor{red}{TODO:Quelle}.
	
\section*{Marshalling}
Die Verwendung von RPC über UDP erfordert eine Serialisierung.
Daher wird eine IDL zur Zuordnung und Serialisierung von Funktionsaufrufen entwickelt\textcolor{red}{TODO: Quelle}.
	
\section*{Namensauflösung}
Für die Namensauflösung wird eine hierarische Struktur gewählt \textcolor{red}{TODO: Quelle}. Durch die funktionale Zerlegung wird jeder Funktion eine Socket-Adresse, bestehend aus IPv4 und Port, zugewiesen. Diese Funktionen gehören jeweils zu einem Prozess bzw. einem Softwareblock. Daraus folgt, dass die Gruppen nach dem Softwareblock, im folgenden Service genannt, bestehen. Jeder Service besteht aus einer Gruppe von Funktionen, denen eine Socket-Adresse zugeordnet ist. Bei Start muss sich also jede Funktion mit Service, Funktionsnamen und Socket-Adresse registrieren. Diese Registrierung ist persistent.

\section*{Fehlerbehandlung}
Fehler während der Kommunikation via RPC über UDP wird toleriert. Durch die Anforderung Safety dürfen UDP Pakete, die nicht rechtzeitig ankommen (Latenz) nicht verarbeitet werden. Dies ist mit dem CAP-Theorem \textcolor{red}{TODO: Quelle} zu begründen, nach dem Konsistenz und Verfügbarkeit nicht gleichzeitig in einem verteilten System bestehen können. Da Konsistenz priorisiert wird, ist die zeitliche Richtigkeit der ankommenden Pakete zu erfassen. 
\textcolor{red}{TODO: WEITER AUSFÜHREN}

%Logging, Timeouts und Wiederholungen von Weiterleitungen. Erkannte Fehler werden der Applikation mitgeteilt \textcolor{red}{TODO: Funktion bestimmen}

\section*{Transparenz}
\textcolor{red}{TODO: WEITER AUSFÜHREN}
Middleware abstrahiert Verbindungsdetails, Adressierung und Datenformate für die Applikation vollständig (Standort-, Zugriffstransparenz).

\section*{Sicherheit / Safety}

\textcolor{red}{TODO: Watchdog }
	

\section{Funktionen}
Aus den vorherigen Feststellungen und den Use-Cases \textcolor{red}{TODO:Abschnitt} ergeben sich folgende Funktionen.

\textcolor{red}{TODO: Weitere Funktionen (atomar))}
\textcolor{red}{TODO:Überprüfen!!!!}

\begin{longtable}{|>{\raggedright\arraybackslash}p{4cm}|>{\raggedright\arraybackslash}p{5cm}|>{\raggedright\arraybackslash}p{5cm}|}
	\caption{Funktionsbeschreibungen} \label{tab:loesungsstrategie} \\
	\hline
	Funktion & Beschreibung & Vor-Nachbedingungen \\
	\hline
	\endfirsthead
	
	\hline
	Funktion & Beschreibung & Vor-Nachbedingungen \\
	\hline
	\endhead
	
	\hline
	\endfoot
	
	
	void register(char* name, char* function, char* socket) & 
	\textbf{Schnittstelle zur Applikation} für eine Funktion eines Services einer Node, um sich zu beim System zu registrieren. 
	% Funktionsname der Callfunktion der Node als Callback / 3. Argument Callback nötig ?
	& Jede Node (Servo) muss seinen eigenen Identifier und Socket vor der Registrierung kennen. 
	\\
	\hline
	
	int registerNewNode(String name, String function, String socket) & 
	Registriert neuen Empfänger in der Namensauflösung 
	& Name ist noch nicht vorhanden; return 0 oder -1
	\\
	\hline
	void invoke(String name, String functionName, String[] argTypes, String[] args)
	& \textbf{Schnittstelle zur Applikation} um RPCs an entfernte Ziele zu senden. 
	& IDL der Middleware kann den Typen Marshallable der Applikation serialisieren
	\\
	\hline
	void call(String functionName, String[] argTypes, String[] args)
	& \textbf{Schnittstelle zur Applikation} um RPC in der lokalen Applikation aufzurufen
	& Die Funktion mit den Parametern muss existieren
	\\
	int marshall(String functionName, String[] argTypes, String[] args, char* buffer, size bufSize)
	& Führt Marshalling durch
	& Marshallable und buffer darf nicht NULL sein. Nach: return 0 oder -1
	\\
	\hline
	int unmarshall(const char* buffer, String functionName, String[] argTypes, String[] args)
	& Führt Unmarshalling durch
	& Marshallable und buffer darf nicht NULL sein. Nach: return 0 oder -1
	\\
	\hline
	void updateAvailableNodes(List<Node> nodes) 
	& Liste mit allen verfügbaren Nodes, um diese der Applikation mitzuteilen. 
	& Es existiert eine Liste die auch von der Applikation gelesen werden kann (Liste muss angepasst werden an die )
	\\
	\hline
	void forwardCall( const char* target, String functionName, String[] argTypes, String[] args)
	& Leitet den ankommenden RPC an das Target weiter
	& Das Target muss existieren.
	\\
	\hline
	char* resolveName(const String* target)
	& Löst den eindeutigen Namen zu einem Socket (IPv4:Port) auf.
	& Vorbedingung: target ungleich NULL; Rückgabe: String mit Socket-Adresse oder NULL bei Fehler.
	\\
	\hline
	\textcolor{red}{TODO: CHECK wegen Watchdog} void heartbeat(Identifier ident)	
	& Check ob Node verfügbar	
	& Vor: Node ist registriert; Nach: Timeout-Zähler zurückgesetzt
	\\
	\hline
	void unregister(Identifier ident)
	& Entfernt eine Node aus dem System, zb wenn nicht mehr erreichbar anhand seines Identifiers
	& Vor: Node ist registriert; Nach: Node ist aus Liste entfernt
	\\
	\hline
	 
\end{longtable}


\section{IDL}

Die IDL dient der Serialisierung und Zuordnung der RPC Aufrufe\\\\
-copy in/ copy out

\subsection{Java}


