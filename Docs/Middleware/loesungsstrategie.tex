\chapter{Lösungsstrategie}


\section*{Kommunikation}
Die losgekoppelte Kopplung \textcolor{red}{TODO: Abschnitt}, fordert eine asynchrone Kommunikation ein. 
Durch die festgelegte funktionale Zerlegung \textcolor{red}{TODO: Abschnitt} ist RPC ein geeigneter Kommunikationsmechanismus \textcolor{red}{TODO: QUELLE}. Die losgekoppelte Kopplung fordert im TCP/IP Stack das Protokoll UDP ein, da TCP als verbindungsorientiertes Protokoll durch die ACK Pakete synchron arbeitet \textcolor{red}{TODO: Quelle}.	 Registrierungsvorgänge werden persistent gespeichert, während Steuerbefehle transient und zeitkritisch behandelt werden. Um sicherzustellen, dass pro RPC Aufruf nur ein UDP-Paket verschickt wird, darf die Payload die Größe von 256 Bytes nicht überschreiten \textcolor{red}{TODO:Quelle}.
	
\section*{Marshalling}
Die Verwendung von RPC über UDP erfordert eine Serialisierung.
Daher wird eine IDL zur Zuordnung und Serialisierung von Funktionsaufrufen entwickelt\textcolor{red}{TODO: Quelle}.
	
\section*{Namensauflösung}
Für die Namensauflösung wird eine hierarische Struktur gewählt \textcolor{red}{TODO: Quelle}. Durch die funktionale Zerlegung wird jeder Funktion eine Socket-Adresse, bestehend aus IPv4 und Port, zugewiesen. Diese Funktionen gehören jeweils zu einem Prozess bzw. einem Softwareblock. Daraus folgt, dass die Gruppen nach dem Softwareblock, im folgenden Service genannt, bestehen. Jeder Service besteht aus einer Gruppe von Funktionen, denen eine Socket-Adresse zugeordnet ist. Bei Start muss sich also jede Funktion mit Service, Funktionsnamen und Socket-Adresse registrieren. Diese Registrierung ist persistent.

\section*{Fehlerbehandlung}
Fehler während der Kommunikation via RPC über UDP wird toleriert. Durch die Anforderung Safety dürfen UDP Pakete, die nicht rechtzeitig ankommen (Latenz) nicht verarbeitet werden. Dies ist mit dem CAP-Theorem \textcolor{red}{TODO: Quelle} zu begründen, nach dem Konsistenz und Verfügbarkeit nicht gleichzeitig in einem verteilten System bestehen können. Da Konsistenz priorisiert wird, ist die zeitliche Richtigkeit der ankommenden Pakete zu erfassen. 
\textcolor{red}{TODO: WEITER AUSFÜHREN}

%Logging, Timeouts und Wiederholungen von Weiterleitungen. Erkannte Fehler werden der Applikation mitgeteilt \textcolor{red}{TODO: Funktion bestimmen}

\section*{Transparenz}
\textcolor{red}{TODO: WEITER AUSFÜHREN}
Middleware abstrahiert Verbindungsdetails, Adressierung und Datenformate für die Applikation vollständig (Standort-, Zugriffstransparenz).

\section*{Sicherheit / Safety}

Durch die Bedingung des CAP-Theorems wird sich durch die Safety-Anforderung\textcolor{red}{TODO:Abschnitt} für die Konsistenz entschieden.
Dadurch bekommt jede RPC-Nachricht, die von der Applikation ausgelöst wurde einen Timestamp, der von dem jeweiligen Empfänger zuvor an den Sender propagiert wurde. So kann der Empfänger sowohl Reihenfolge als auch Rechtzeitigkeit bestimmen. Aus den Qualitätszielen\textcolor{red}{TODO:Abschnitt} geht hierbei eine maximale Differenz zwischen Auslösen der Funktion und Ankommen des RPC-Pakets von 250 ms hervor.
	

\section{Funktionen}
Aus den vorherigen Feststellungen und den Use-Cases \textcolor{red}{TODO:Abschnitt} ergeben sich folgende Funktionen.

\textcolor{red}{TODO: Weitere Funktionen (atomar))}
\textcolor{red}{TODO:Überprüfen!!!!}

\begin{longtable}{|>{\raggedright\arraybackslash}p{4cm}|>{\raggedright\arraybackslash}p{5cm}|>{\raggedright\arraybackslash}p{5cm}|}
	\caption{Funktionsbeschreibungen} \label{tab:loesungsstrategie} \\
	\hline
	Funktion & Beschreibung & Vor-Nachbedingungen \\
	\hline
	\endfirsthead
	
	\hline
	Funktion & Beschreibung & Vor-Nachbedingungen \\
	\hline
	\endhead
	
	\hline
	\endfoot
	
	
	void register(string service, string function, string socket) & 
	\textbf{Schnittstelle zur Applikation} für eine Funktion eines Services einer Node, um sich zu beim System zu registrieren. 
	% Funktionsname der Callfunktion der Node als Callback / 3. Argument Callback nötig ?
	& Jede Node (Servo) muss seinen eigenen Identifier und Socket vor der Registrierung kennen. 
	\\
	\hline
	void invoke(string functionName, string[] paramTypes, string[] params)
	& \textbf{Schnittstelle zur Applikation} um RPCs an entfernte Ziele zu senden. 
	& IDL der Middleware kann den Typen Marshallable der Applikation serialisieren
	\\
	\hline
	void call(string functionName, string[] argTypes, string[] args) \textcolor{red}{TODO:Überprüfen} 
	& \textbf{Schnittstelle zur Applikation} um RPC in der lokalen Applikation aufzurufen
	& Die Funktion mit den Parametern muss existieren
	\\
	int marshall(string functionName, string[] paramTypes, string[] params, string payload, uint32\_t timestamp)
	& Führt Marshalling durch
	& Marshallable und buffer darf nicht NULL sein. Nach: return 0 oder -1
	\\
	\hline
	void unmarshall(string payload, string functionName, string[] paramTypes, string[] params)
	& Führt Unmarshalling durch
	& Marshallable und buffer darf nicht NULL sein. Nach: return 0 oder -1
	\\
	\hline
	void updateAvailableNodes(List<Node> nodes) \textcolor{red}{TODO:Anpassen} 
	& Liste mit allen verfügbaren Nodes, um diese der Applikation mitzuteilen. 
	& Es existiert eine Liste die auch von der Applikation gelesen werden kann (Liste muss angepasst werden an die )
	\\
	\hline
	void forwardCall( const char* target, String functionName, String[] argTypes, String[] args)\textcolor{red}{TODO:Anpassen} 
	& Leitet den ankommenden RPC an das Target weiter
	& Das Target muss existieren.
	\\
	\hline
	string resolve(string servicename, string functionname)
	& Im nameserverst den eindeutigen Namen zu einem Socket (IPv4:Port) auf.
	& Vorbedingung: target ungleich NULL; Rückgabe: String mit Socket-Adresse oder NULL bei Fehler.
	\\
	\hline
	\textcolor{red}{TODO: CHECK wegen Watchdog} void heartbeat(Identifier ident)	
	& Check ob Node verfügbar	
	& Vor: Node ist registriert; Nach: Timeout-Zähler zurückgesetzt
	\\
	\hline
	%void unregister(Identifier ident)
	%& Entfernt eine Node aus dem System, zb wenn nicht mehr erreichbar anhand seines Identifiers
	%& Vor: Node ist registriert; Nach: Node ist aus Liste entfernt
	%\\
	%\hline
	bool set_or_update_timestamp(string servicename, string function, int timestamp)
	&interne funktion, die einen Timestamp setzt wenn empfangen
	& Vor: servicename, function nicht NULL Nach: true, wenn erfolgreich, false, wenn nicht
	\\
	\hline
	bool get_timestamp(string servicename, string function, int out_timestamp)
	&interne funktion, die einen Timestamp ausliest
	& Vor: servicename, function nicht NULL Nach: true, wenn erfolgreich, false, wenn nicht
	\\
	\hline
	int cache_store(string servicename, string functionname, string socket, int time);
	& interne funktion, die einen socket in den cache legt
	& Vor: servicename, function nicht NULL Nach: 0, wenn erfolgreich, -1, wenn nicht
\end{longtable}

%bool set_or_update_timestamp(const char *servicename, const char* function, uint32_t timestamp);
%bool get_timestamp(const char *servicename, const char* function, uint32_t *out_timestamp);
%int cache_store(const char* servicename, const char* functionname, const char* socket, uint32_t time);





\section{IDL}

Die IDL dient der Serialisierung und Zuordnung der RPC Aufrufe. Zur Serialisierung eignen sich 
\subsection{copy in/ copy out}
Zum Senden der RPC werden die Nachrichten in eine Nachricht kopiert, damit direkte Speciherzugriffe verhindert werden.  \textcolor{red}{TODO:Quelle} Dafür wird ein Format gefunden das für alle Nodes im verteilten System gleich ist. Unter anderem ist JSON ein geeignetes Forma  \textcolor{red}{TODO:Quelle}.  Dieses ist einfach zu verstehen und an für diese Anwendung einen angemessenen Overhead. Zudem ist JSON ein offenener Standard. Andere Formate wie XML haben einen größeren Overhead und sind für die Umsetzung eher nicht geeignet, da auch das Parsen komplexer ist  \textcolor{red}{TODO:Quelle}.  


Das JSON ist folgendermaßen aufgebaut:

\begin{verbatim}
	{
		"timeStamp": <int>,
		"function": "<function_name>",
		"params": ["<p1 of Type string>", <p2 of Type int>, "..."]
	}
\end{verbatim}


Für das Marshalling entsteht somit folgende Tabelle:


\begin{table}[h!]
	\centering
	\begin{tabular}{|l|l|c|}
		\hline
		\textbf{Funktionsname} & \textbf{Parameter-Typen} & \textbf{Anzahl Parameter} \\
		\hline
		\texttt{updateView} & [byte[], int, bool, bool] & 4 \\
		\texttt{move} & [int] & 1 \\
		%\texttt{registerActuator} & [string, bool] & 2 \\
		\texttt{reportHealth} & [string, string] & 2 \\
		\texttt{register} & [string, string, string] & 3 \\
		\texttt{select} & [int] & 1 \\
		\texttt{heartbeat} & [string] & 1 \\
		\texttt{resolve} & [string, string, string] & 3 \\
		\texttt{receiveResolution} & [string, string, string] & 3 \\
		\texttt{setTimestamp} & [string, string, int] & 3 \\
		
		\hline
	\end{tabular}
	\caption{RPC-Funktionen mit Parametertypen}
\end{table}

%void updateView(robots:String[],selected: int, error:bool, confirm: bool), 
%void move(ActuatorDirection:actuatorDirection), 
%void move(robotDirection:RobotDirection),
%void registerActuator(actuatorName: String,isAlive: boolean), 
%void select(SelectDirection selectDirection),
%void reportHealth(serviceName: String, subscription: String)

Das ByteArray für die Funktion \texttt{updateView} wird aus der Liste von Roboterarmen generiert. Grund dafür ist die Beschränkung, dass die Größe eines einzelnen UDP-Pakets nicht 256 Byte überschreiten darf \textcolor{red}{TODO:Abschnitt}. Daher gibt es acht 32-bit große Integer, also 256 Bit. Jedes Bit repräsentiert einen Roboterarm. Damit ist R0 Bit 0 von Integer 1, R256 ist Bit 32 von Integer 8.











