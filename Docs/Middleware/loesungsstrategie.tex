\chapter{Lösungsstrategie}


\section*{Kommunikation}
Die losgekoppelte Kopplung, fordert eine asynchrone Kommunikation ein. 
Durch die festgelegte funktionale Zerlegung ist RPC ein geeigneter Kommunikationsmechanismus. Die losgekoppelte Kopplung fordert im TCP/IP Stack das Protokoll UDP ein, da TCP als verbindungsorientiertes Protokoll durch die ACK Pakete synchron arbeitet. Registrierungsvorgänge werden während der Laufzeit gespeichert, während Steuerbefehle transient und zeitkritisch behandelt werden. Um sicherzustellen, dass pro RPC Aufruf nur ein UDP-Paket verschickt wird, darf die Payload die Größe von 256 Bytes nicht überschreiten.
	
\section*{Marshalling}
Die Verwendung von RPC über UDP erfordert eine Serialisierung.
Daher wird eine IDL zur Zuordnung und Serialisierung von Funktionsaufrufen entwickelt.
	
\section*{Namensauflösung}
Für die Namensauflösung wird eine hierarische Struktur gewählt. Durch die funktionale Zerlegung wird jeder Funktion eine Socket-Adresse, bestehend aus IPv4 und Port, zugewiesen. Diese Funktionen gehören jeweils zu einem Prozess bzw. zu einem Softwareblock. Daraus folgt, dass die Gruppen nach dem Softwareblock, im folgenden Service genannt, bestehen. Jeder Service besteht aus einer Gruppe von Funktionen, denen jeweils eine individuelle Socket-Adresse zugeordnet ist. Bei Start muss sich also jede Funktion mit Service, Funktionsnamen und Socket-Adresse registrieren.

\section*{Fehlerbehandlung}
Fehler während der Kommunikation via RPC über UDP wird toleriert. Durch die Anforderung Safety dürfen UDP Pakete, die nicht rechtzeitig ankommen (Latenz) nicht verarbeitet werden. Dies ist mit dem CAP-Theorem zu begründen, nach dem Konsistenz und Verfügbarkeit nicht gleichzeitig in einem verteilten System bestehen können. Da Konsistenz priorisiert wird, ist die zeitliche Richtigkeit der ankommenden Pakete zu erfassen. 

%Logging, Timeouts und Wiederholungen von Weiterleitungen. Erkannte Fehler werden der Applikation mitgeteilt \textcolor{red}{TODO: Funktion bestimmen}

\section*{Sicherheit / Safety}

Durch die Bedingung des CAP-Theorems wird sich durch die Safety-Anforderung für die Konsistenz entschieden.
Dadurch bekommt jede RPC-Nachricht, die von der Applikation ausgelöst wurde einen Timestamp, der von dem jeweiligen Empfänger zuvor an den Sender propagiert wurde. So kann der Empfänger sowohl Reihenfolge als auch Rechtzeitigkeit bestimmen. Aus den Qualitätszielen geht hierbei eine maximale Differenz zwischen Auslösen der Funktion und Ankommen des RPC-Pakets von 250 ms hervor.
	

\section{Funktionen}
Aus den vorherigen Feststellungen und den Use-Cases ergeben sich folgende Funktionen.

\begin{longtable}{|>{\raggedright\arraybackslash}p{4cm}|>{\raggedright\arraybackslash}p{5cm}|>{\raggedright\arraybackslash}p{5cm}|}
	\caption{Funktionsbeschreibungen RPC-Kommunikation} \label{tab:loesungsstrategie} \\
	\hline
	Funktion & Beschreibung & Vor-Nachbedingungen \\
	\hline
	\endfirsthead
	
	\hline
	Funktion & Beschreibung & Vor-Nachbedingungen \\
	\hline
	\endhead
	
	\hline
	\endfoot
	
	void invoke(string functionName, RpcValue[] params)
	& \textbf{Schnittstelle zur Applikation} um RPCs an entfernte Ziele zu senden. 
	& IDL der Middleware kann den Typen Marshallable der Applikation serialisieren
	\\
	\hline
	void call(string functionName, RpcValue[] args)
	& \textbf{Schnittstelle zur Applikation} um RPC in der lokalen Applikation aufzurufen
	& Die Funktion mit den Parametern muss existieren
	\\
	int marshall(string functionName, RpcValue[] params, string* payload, uint32\_t timestamp)
	& Führt Marshalling durch
	& Marshallable und buffer darf nicht NULL sein. Nach: return 0 oder -1
	\\
	\hline
	void unmarshall(string payload, string functionName, RpcValue[] params, uint32\_t timestamp)
	& Führt Unmarshalling durch
	& Marshallable und buffer darf nicht NULL sein. Nach: return 0 oder -1
	\\
	\hline
	void setTimestamp(string servicename, string function, uint32\_t timestamp)
	& RPC-Funktion, die einen Timestamp bei anderen Teilnehmer setzt
	& Vor: servicename, function nicht NULL 
	\\
	\hline
	bool set\_or\_update\_timestamp(string servicename, string function, int timestamp)
	& interne funktion, die einen Timestamp setzt wenn empfangen
	& Vor: servicename, function nicht NULL Nach: true, wenn erfolgreich, false, wenn nicht
	\\
	\hline
	bool get\_timestamp(string servicename, string function, int out\_timestamp)
	& interne funktion, die einen Timestamp ausliest
	& Vor: servicename, function nicht NULL Nach: true, wenn erfolgreich, false, wenn nicht
	\\
	\hline
	int cache\_store(string servicename, string functionname, string socket, int time);
	& interne funktion, die einen socket in den cache legt
	& Vor: servicename, function nicht NULL Nach: 0, wenn erfolgreich, -1, wenn nicht
	\\
	\hline
	string cache\_lookup(string servicename, string functionname);
	& interne funktion, die einen socket aus dem cache liest
	& Vor: socket oder null
\end{longtable}
 

\begin{longtable}{|>{\raggedright\arraybackslash}p{4cm}|>{\raggedright\arraybackslash}p{5cm}|>{\raggedright\arraybackslash}p{5cm}|}
	\caption{Funktionsbeschreibungen Name Service} \label{tab:loesungsstrategie} \\
	\hline
	Funktion & Beschreibung & Vor-Nachbedingungen \\
	\hline
	\endfirsthead
	
	\hline
	Funktion & Beschreibung & Vor-Nachbedingungen \\
	\hline
	\endhead
	
	\hline
	\endfoot
	
	void register(string service, string function, string socket) & 
	\textbf{Schnittstelle zur Applikation} für eine Funktion eines Services einer Node, um sich zu beim System zu registrieren. 
	% Funktionsname der Callfunktion der Node als Callback / 3. Argument Callback nötig ?
	& Jede Node (Servo) muss seinen eigenen Identifier und Socket vor der Registrierung kennen. 
	\\
	\hline
	string resolve(string servicename, string functionname)
	& Im Namens-Server löst den eindeutigen Namen zu einem Socket (IPv4:Port) auf.
	& Vorbedingung: target ungleich NULL; Rückgabe: String mit Socket-Adresse oder NULL bei Fehler.
	\\
	\hline
	void receiveResolution(string servicename, string functionname, string resolvedSocket)
	& 
	& Vorbedingung: servicename ungleich NULL; functionname ungleich NULL ; resolvedSocket ungleich NULL
	\\
	\hline
\end{longtable}


\begin{longtable}{|>{\raggedright\arraybackslash}p{4cm}|>{\raggedright\arraybackslash}p{5cm}|>{\raggedright\arraybackslash}p{5cm}|}
	\caption{Funktionsbeschreibungen Watchdog} \label{tab:loesungsstrategie} \\
	\hline
	Funktion & Beschreibung & Vor-Nachbedingungen \\
	\hline
	\endfirsthead
	
	\hline
	Funktion & Beschreibung & Vor-Nachbedingungen \\
	\hline
	\endhead
	
	\hline
	\endfoot
	
	
	void notifySubscribersPeriodically() 
	& interne Funktion, die Subscriber periodisch benachrichtigt
	&  
	\\
	\hline
	void checkTimouts() & 
	interne Funktion, überprüft die Gesundheit der bekannten Services
	&  
	\\
	\hline
	void heartbeat(string servicename)
	& Benachrichtigt Watchdog, dass Service noch lebt
	& Vorbedingung: servicename ungleich NULL; 
	\\
	\hline
	void subscribe(string servicename, string patternString)
	& Benachrichtig dem Watchdog, dass der sendene Service über Gesundheit von Services benachricht werden möchte. 
	& Vorbedingung: servicename ungleich NULL, patternString ungleich NULL, ist explizit oder RegEx
	\\
	\hline
	
	
	
\end{longtable}

\section{IDL}

Die IDL dient der Serialisierung und Zuordnung der RPC Aufrufe. Zur Serialisierung eignen sich 
\subsection{copy in/ copy out}
Zum Senden der RPC werden die Nachrichten in eine Nachricht kopiert, damit direkte Speciherzugriffe verhindert werden. Dafür wird ein Format gefunden das für alle Nodes im verteilten System gleich ist. Unter anderem ist JSON ein geeignetes Format. Dieses ist einfach zu verstehen und an für diese Anwendung einen angemessenen Overhead. Zudem ist JSON ein offenener Standard. Andere Formate wie XML haben einen größeren Overhead und sind für die Umsetzung eher nicht geeignet, da auch das Parsen komplexer ist.  


Das JSON-RPC ist folgendermaßen aufgebaut:

\begin{verbatim}
	{
		"timeStamp": <int>,
		"function": "<function_name>",
		"params": ["<p1 of Type string>", <p2 of Type int>, "..."]
	}
\end{verbatim}


Für das Marshalling entsteht somit folgende Tabelle:


\begin{table}[h!]
	\centering
	\begin{tabular}{|l|l|c|}
		\hline
		\textbf{Funktionsname} & \textbf{Parameter-Typen} & \textbf{Anzahl Parameter} \\
		\hline
		\texttt{resolve} & [string, string, string] & 3 \\
		\texttt{receiveResolution} & [string, string, string] & 3 \\
		\texttt{register} & [string, string, string] & 3 \\
		
		\texttt{heartbeat} & [string] & 1 \\
		\texttt{subscribe} & [string, string] & 2 \\
		\texttt{reportHealth} & [string, string] & 2 \\	
		
		\texttt{setTimestamp} & [string, string, int] & 3 \\
				
		\texttt{move} & [int] & 1 \\
		\texttt{select} & [int] & 1 \\
		\texttt{updateView} & [byte[], int, bool, bool] & 4 \\
		
		\texttt{update} & [byte[], int, bool, bool] & 4 \\
		
		\hline
	\end{tabular}
	\caption{RPC-Funktionen mit Parametertypen}
\end{table}


Alle Parameter-Typen sind primitive Datentypen und sind ein einem Marshalling-Typ (RpcValue) zusammengefasst.
Das ByteArray für die Funktion \texttt{updateView} wird aus der Liste von Roboterarmen generiert. Grund dafür ist die Beschränkung, dass die Größe eines einzelnen UDP-Pakets nicht 256 Byte überschreiten darf. Daher gibt es acht 32-bit große Integer, also 256 Bit. Jedes Bit repräsentiert einen Roboterarm. Damit ist R0 Bit 0 von Integer 1, R256 ist Bit 32 von Integer 8. 











